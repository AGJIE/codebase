# 语言基础

## 函数

函数：函数就是可以重复执行的代码块

### 函数定义 | 调用：

```javascript
//定义
function add() { //add 函数名
	//程序
}

//调用
add();
```

### 传递参数

ECMAScript中，所有函数的参数都是按值传递的

### 形参 | 实参

形参：相当于函数中定义的变量

实参：在运行时的函数调用时传入的参数。

说明白就是，形参就是函数声明时的变量，实参是我们调用该函数时传入的具体参数。

#### 特性：

其它语言中实参个数必须和形参个数一致，但是JavaScript中没有函数签名的概念，实参个数和形参个数可以不相等

### 重载-没有

函数重载：一组具有相同名字，不同参数列表的函数或者方法;

### 返回值

- 未显式地设置函数的返回值，函数默认返回：undefined
- 每个函数都有一个返回值，返回值通过“*return*”进行设置
- 在函数中，一旦执行完“return”语句，后续语句将不再执行；
- “return”的值只能有一个。如果需要函数返回多个值，只有将值组合成一个对象或数组进行返回

### 定义方式

#### 函数声明

```
function add(num1, num2) {
	return num1+num2;
}
```

#### 函数表达式

```javascript
//第一种
var add = function(num1, num2) {
	return num1+num2;
}

//第二种
(function text() {....})

//第三种
!function text() {...}
```

### 匿名函数

没有命名的函数

作用：一般用在绑定事件的时候

语法：

```
function () {
	...
}
```

### 函数自执行

```javascript
//第一种
var fun = function () {
    ...
}();

//第二种
(function () {
    ...
})();
    
//第三种
var fun = function() {
    ...
}();
```

### 变量的作用域

1. 在js中，变量的定义并**不是以代码块作为作用域**的，而是**以函数作为作用域**。也就是说，如果变量是在某个函数中定义的，那么，它在函数以外的地方是不可见的。但是，如果该变量是定义在if或者for这样的代码块中，它在代码块之外是可见的。
2. 在js中，术语“**全局变量**”指的是定义在所有函数之外的变量（也就是定义在全局代码中的变量），与之相对的是“**局部变量**”，所指的是在某个函数中定义的变量。其中，函数内的代码可以像访问自己的局部变量那样访问全局变量，反之则不行。
3. 下面是具体示例，请注意两点：
   1. 函数f()可以访问变量global
   2. 在函数f()以外，变量local是不存在的。
4. 还有一点要注意：如果我们声明一个变量事没有使用var语句，该变量就会被默认为全局变量。

#### 块级作用域

- 在其它语言中，任何一对花括号中的语句都属于一个块，在这之中定义的所有变量在代码块外都是不可见的
- JavaScript中没有块级作用域

#### 全局变量

定义在script或者不属于某个函数的变量

#### 局部变量

定义在函数内部的变量

#### 其它

函数内部可以访问到该函数所属的外部作用域的变量(作用域链)
不使用var声明的变量是全局变量，不推荐使用。
变量退出作用域之后会销毁，全局变量关闭网页或浏览器才会销毁



### 变量提升

#### 变量提升

定义变量的时候，变量的声明会被提升到作用域的最上面，变量的赋值不会提升。

#### 函数提升

JavaScript解析器首先会把当前作用域的函数声明提前到整个作用域的最前面

### 递归

递归函数就是在函数体内调用本函数；

递归函数的使用要注意函数终止条件避免死循环；

 递归返回值

1.递归函数相当于一种循环调用，需要避免死循环，给定一个条件停止调用

2.递归函数的返回值要返回整个函数

### 回调函数

什么是回调函数？
简单理解就是函数做为参数。（这样的......）
复杂理解：回调函数就是一个通过函数调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。



回调函数是一个函数，将会在另一个函数完成执行后立即执行。回调函数是一个作为参数传给另一个 JavaScript 函数的函数。这个回调函数会在传给的函数内部执行。

```
		function title(value){//这是回调函数！！！！
			alert(value);
		}
		function main(title, value){//这个主函数:在参数列表中，title作为一个参数传递进来，也就是上文说的 参数化函数；然后value这个值正是title（）函数中所需要的。
			alert("我是主函数");
			title(value);//结果为：'我是回调函数'。——————然后在这行这个title()，它就是回调函数咯。
		}
		main(title,"我是回调函数");//title参数加上()后，就会变回一个函数，并会被执行一次。
		//PS:看清楚，调用的是main()函数，意味着先执行main()，这时已经执行了主函数，title()被main()在函数体中执行了一次，因此title()是回调函数。

```

将回调函数的参数作为与回调函数同等级的参数进行传递。

回调函数的参数在调用回调函数内部创建。



字面上的理解，回调函数就是传递一个参数化的函数，就是将这个函数作为一个参数传到另一个主函数里面，当那一个主函数执行完之后，再执行传进去的作为参数的函数。走这个过程的参数化的函数 就叫做回调函数。

### 函数是一种数据类型

typeof  f1
函数作为方法的参数
函数作为方法的返回值

#### 工厂模式

```javascript
function createObject(name, age, sex) {
    var obj = {};
    obj.name = name;
    obj.age = age;
    obj.sex = sex;
    obj.getHello = function () {
        console.log("你好");
    }
    return obj;
}

var person1 = createObject();
```

把实现同一件事情的相同的代码放到一个函数中，以后如果再想实现这个功能，不需要从新的编写这些代码来了，只需要执行当前的函数即可-->"函数的封装"-->"低耦合高内聚":减少页面中的冗余代码，提高代码的重复利用率

即：把实现同一事情的相同代码，放到一个函数中，以后如果再想实现这个功能，就不需要重新编写这些代码了，只要执行当前的函数即可，

这就是函数的封装，体现了高内聚、低耦合的思想：减少页面的中的冗余代码，提高代码的重复利用率：

#### 构造函数模式

```javascript
function Person(name, age, sex){
    this.name = name;
    this.age = age;
    this.sex = sex;
    this.sayName = function() {
        alert(this.name)
    }
};

var person1 = new Person("Greg", 18, "男");
```

#### 原型模式

```javascript
function Person(name, age, sex) {
    this.name = name;
    this.age = age;
    this.sex = sex;
}

Person.prototype.sayName = function(){
    alert(this.name);
};

var person1 = new Person();
var person2 = new Person();
alert(person1.sayName == person1.sayName); //true
```

